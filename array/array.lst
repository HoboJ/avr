   1               		.file	"array.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.global __do_copy_data
   8               		.global __do_clear_bss
   9               		.text
  10               	.Ltext0:
  11               	.global	decode
  13               	decode:
  14               	.LFB5:
  15               		.file 1 "array.c"
   1:array.c       **** /* array.c
   2:array.c       ****  * 
   3:array.c       ****  * T. Hennessy
   4:array.c       ****  *
   5:array.c       ****  * Description: Driving a 7 segment display with PORTD while using
   6:array.c       ****  * PORTB as input
   7:array.c       ****  */
   8:array.c       **** 
   9:array.c       **** #include <avr/io.h>
  10:array.c       **** #include <util/delay.h>
  11:array.c       **** 
  12:array.c       **** 
  13:array.c       **** int decode (void);
  14:array.c       **** 
  15:array.c       **** 
  16:array.c       **** int main (void)
  17:array.c       **** {
  18:array.c       ****     int digits[10];
  19:array.c       ****     int count = 0;
  20:array.c       **** 
  21:array.c       ****     digits[0] = 0xC0;
  22:array.c       ****     digits[1] = 0xF9;
  23:array.c       ****     digits[2] = 0xA4;
  24:array.c       ****     digits[3] = 0xB0;
  25:array.c       ****     digits[4] = 0x99;
  26:array.c       ****     digits[5] = 0x92;
  27:array.c       ****     digits[6] = 0x82;
  28:array.c       ****     digits[7] = 0xF8;
  29:array.c       ****     digits[8] = 0x80;
  30:array.c       ****     digits[9] = 0x98;
  31:array.c       ****     
  32:array.c       ****     DDRD = 0xFF; //set PORTD for output
  33:array.c       ****     DDRB = 0x00; //set PORTB for input
  34:array.c       **** 
  35:array.c       ****     while(count <= 4) {
  36:array.c       **** 
  37:array.c       ****         int value = decode(); //figure out which number to display on the leds
  38:array.c       ****         
  39:array.c       ****         if(value != 10) {
  40:array.c       ****             PORTD = digits[value];
  41:array.c       ****             _delay_ms(1000);
  42:array.c       ****         }
  43:array.c       ****         else {
  44:array.c       ****             PORTD = 0xFF;
  45:array.c       ****             _delay_ms(4000);
  46:array.c       ****         }
  47:array.c       ****         count++;
  48:array.c       ****         
  49:array.c       ****     }
  50:array.c       **** 
  51:array.c       ****     return 0;
  52:array.c       **** }
  53:array.c       **** 
  54:array.c       **** int decode(void)
  55:array.c       **** {
  16               		.loc 1 55 0
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  56:array.c       **** 
  57:array.c       ****     int input, value;
  58:array.c       **** 
  59:array.c       ****     PORTB = input;
  21               		.loc 1 59 0
  22 0000 15B8      		out 37-0x20,__zero_reg__
  23               	.LVL0:
  60:array.c       ****     
  61:array.c       ****     switch (input) {
  62:array.c       ****         case 0x01:
  63:array.c       ****             value = 0;
  64:array.c       ****             break;
  65:array.c       ****         case 0x02:
  66:array.c       ****             value = 1;
  67:array.c       ****             break;
  68:array.c       ****         case 0x04:
  69:array.c       ****             value = 2;
  70:array.c       ****             break;
  71:array.c       ****         case 0x08:
  72:array.c       ****             value = 3;
  73:array.c       ****             break;
  74:array.c       ****         case 0x10:
  75:array.c       ****             value = 4;
  76:array.c       ****             break;
  77:array.c       ****         case 0x20:
  78:array.c       ****             value = 5;
  79:array.c       ****             break;
  80:array.c       ****         case 0x40:
  81:array.c       ****             value = 6;
  82:array.c       ****             break;
  83:array.c       ****         case 0x80:
  84:array.c       ****             value = 7;
  85:array.c       ****             break;
  86:array.c       ****         default:
  87:array.c       ****             value = 10;
  24               		.loc 1 87 0
  25 0002 8AE0      		ldi r24,lo8(10)
  26 0004 90E0      		ldi r25,hi8(10)
  27               	.LVL1:
  28               	/* epilogue start */
  88:array.c       ****     }
  89:array.c       **** 
  90:array.c       ****     return value;
  91:array.c       **** 
  92:array.c       **** }       
  29               		.loc 1 92 0
  30 0006 0895      		ret
  31               	.LFE5:
  33               		.section	.text.startup,"ax",@progbits
  34               	.global	main
  36               	main:
  37               	.LFB4:
  17:array.c       **** {
  38               		.loc 1 17 0
  39 0000 DF92      		push r13
  40               	.LCFI0:
  41 0002 EF92      		push r14
  42               	.LCFI1:
  43 0004 FF92      		push r15
  44               	.LCFI2:
  45 0006 0F93      		push r16
  46               	.LCFI3:
  47 0008 1F93      		push r17
  48               	.LCFI4:
  49 000a CF93      		push r28
  50               	.LCFI5:
  51 000c DF93      		push r29
  52               	.LCFI6:
  53 000e CDB7      		in r28,__SP_L__
  54 0010 DEB7      		in r29,__SP_H__
  55 0012 6497      		sbiw r28,20
  56               	.LCFI7:
  57 0014 0FB6      		in __tmp_reg__,__SREG__
  58 0016 F894      		cli
  59 0018 DEBF      		out __SP_H__,r29
  60 001a 0FBE      		out __SREG__,__tmp_reg__
  61 001c CDBF      		out __SP_L__,r28
  62               	/* prologue: function */
  63               	/* frame size = 20 */
  64               	/* stack size = 27 */
  65               	.L__stack_usage = 27
  66               	.LVL2:
  21:array.c       ****     digits[0] = 0xC0;
  67               		.loc 1 21 0
  68 001e 80EC      		ldi r24,lo8(192)
  69 0020 90E0      		ldi r25,hi8(192)
  70 0022 9A83      		std Y+2,r25
  71 0024 8983      		std Y+1,r24
  22:array.c       ****     digits[1] = 0xF9;
  72               		.loc 1 22 0
  73 0026 89EF      		ldi r24,lo8(249)
  74 0028 90E0      		ldi r25,hi8(249)
  75 002a 9C83      		std Y+4,r25
  76 002c 8B83      		std Y+3,r24
  23:array.c       ****     digits[2] = 0xA4;
  77               		.loc 1 23 0
  78 002e 84EA      		ldi r24,lo8(164)
  79 0030 90E0      		ldi r25,hi8(164)
  80 0032 9E83      		std Y+6,r25
  81 0034 8D83      		std Y+5,r24
  24:array.c       ****     digits[3] = 0xB0;
  82               		.loc 1 24 0
  83 0036 80EB      		ldi r24,lo8(176)
  84 0038 90E0      		ldi r25,hi8(176)
  85 003a 9887      		std Y+8,r25
  86 003c 8F83      		std Y+7,r24
  25:array.c       ****     digits[4] = 0x99;
  87               		.loc 1 25 0
  88 003e 89E9      		ldi r24,lo8(153)
  89 0040 90E0      		ldi r25,hi8(153)
  90 0042 9A87      		std Y+10,r25
  91 0044 8987      		std Y+9,r24
  26:array.c       ****     digits[5] = 0x92;
  92               		.loc 1 26 0
  93 0046 82E9      		ldi r24,lo8(146)
  94 0048 90E0      		ldi r25,hi8(146)
  95 004a 9C87      		std Y+12,r25
  96 004c 8B87      		std Y+11,r24
  27:array.c       ****     digits[6] = 0x82;
  97               		.loc 1 27 0
  98 004e 82E8      		ldi r24,lo8(130)
  99 0050 90E0      		ldi r25,hi8(130)
 100 0052 9E87      		std Y+14,r25
 101 0054 8D87      		std Y+13,r24
  28:array.c       ****     digits[7] = 0xF8;
 102               		.loc 1 28 0
 103 0056 88EF      		ldi r24,lo8(248)
 104 0058 90E0      		ldi r25,hi8(248)
 105 005a 988B      		std Y+16,r25
 106 005c 8F87      		std Y+15,r24
  29:array.c       ****     digits[8] = 0x80;
 107               		.loc 1 29 0
 108 005e 80E8      		ldi r24,lo8(128)
 109 0060 90E0      		ldi r25,hi8(128)
 110 0062 9A8B      		std Y+18,r25
 111 0064 898B      		std Y+17,r24
  30:array.c       ****     digits[9] = 0x98;
 112               		.loc 1 30 0
 113 0066 88E9      		ldi r24,lo8(152)
 114 0068 90E0      		ldi r25,hi8(152)
 115 006a 9C8B      		std Y+20,r25
 116 006c 8B8B      		std Y+19,r24
  32:array.c       ****     DDRD = 0xFF; //set PORTD for output
 117               		.loc 1 32 0
 118 006e 8FEF      		ldi r24,lo8(-1)
 119 0070 8AB9      		out 42-0x20,r24
  33:array.c       ****     DDRB = 0x00; //set PORTB for input
 120               		.loc 1 33 0
 121 0072 14B8      		out 36-0x20,__zero_reg__
 122 0074 05E0      		ldi r16,lo8(5)
 123 0076 10E0      		ldi r17,hi8(5)
 124               	.LBB19:
  44:array.c       ****             PORTD = 0xFF;
 125               		.loc 1 44 0
 126 0078 DD24      		clr r13
 127 007a DA94      		dec r13
 128               	.LBB20:
 129               	.LBB21:
 130               	.LBB22:
 131               	.LBB23:
 132               		.file 2 "/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h"
   1:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
   5:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
   8:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  11:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  16:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  20:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  32:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  34:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  37:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  39:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** #endif
  43:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     \code
  47:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  50:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  58:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  65:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  67:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** */
  68:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  69:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  71:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     register.
  76:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  77:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** */
  80:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** void
  81:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** {
  83:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 	);
  89:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** }
  90:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  91:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  93:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 
  99:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h ****  */
 102:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** void
 103:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** {
 105:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 133               		.loc 2 105 0
 134 007c 39E1      		ldi r19,lo8(25)
 135 007e E32E      		mov r14,r19
 136 0080 F12C      		mov r15,__zero_reg__
 137               	.LVL3:
 138               	.L19:
 139               	.LBE23:
 140               	.LBE22:
 141               	.LBE21:
 142               	.LBE20:
  37:array.c       ****         int value = decode(); //figure out which number to display on the leds
 143               		.loc 1 37 0
 144 0082 0E94 0000 		call decode
 145               	.LVL4:
  39:array.c       ****         if(value != 10) {
 146               		.loc 1 39 0
 147 0086 8A30      		cpi r24,10
 148 0088 9105      		cpc r25,__zero_reg__
 149 008a 01F0      		breq .L15
  40:array.c       ****             PORTD = digits[value];
 150               		.loc 1 40 0
 151 008c FC01      		movw r30,r24
 152 008e EE0F      		lsl r30
 153 0090 FF1F      		rol r31
 154 0092 81E0      		ldi r24,lo8(1)
 155 0094 90E0      		ldi r25,hi8(1)
 156               	.LVL5:
 157 0096 8C0F      		add r24,r28
 158 0098 9D1F      		adc r25,r29
 159 009a E80F      		add r30,r24
 160 009c F91F      		adc r31,r25
 161 009e 8081      		ld r24,Z
 162 00a0 8BB9      		out 43-0x20,r24
 163               	.LVL6:
 164 00a2 80E1      		ldi r24,lo8(10000)
 165 00a4 97E2      		ldi r25,hi8(10000)
 166               	.LVL7:
 167               	.L16:
 168               	.LBB27:
 169               	.LBB28:
 170               	.LBB29:
 171               	.LBB30:
 172               		.loc 2 105 0
 173 00a6 F701      		movw r30,r14
 174               	/* #APP */
 175               	 ;  105 "/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h" 1
 176 00a8 3197      		1: sbiw r30,1
 177 00aa 01F4      		brne 1b
 178               	 ;  0 "" 2
 179               	.LVL8:
 180               	/* #NOAPP */
 181 00ac 0197      		sbiw r24,1
 182               	.LBE30:
 183               	.LBE29:
 184               		.file 3 "/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h"
   1:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2103 2010-03-17 05:16:10Z joerg_wunsch $ */
  34:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 0
  40:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  45:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /** \file */
  46:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  47:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     \code
  48:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  49:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  50:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  51:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     \endcode
  52:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  54:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  55:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  56:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     used.
  57:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  58:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  59:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  60:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  61:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  62:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  63:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  64:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  65:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  66:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  67:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  68:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  69:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  70:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  71:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  72:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  73:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  74:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     routines linked into the application.
  75:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  76:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  77:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  78:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  79:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  80:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** */
  81:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  83:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  84:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #endif
  86:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  87:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  88:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  89:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  90:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  91:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #endif
  92:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  93:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  94:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  95:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #endif
  96:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** /**
  98:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    \ingroup util_delay
  99:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 101:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 103:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 104:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
 105:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 106:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 
 107:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 108:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 109:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 110:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 111:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 112:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h ****  */
 113:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** void
 114:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 115:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** {
 116:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 117:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 118:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__)
 119:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 120:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__tmp);
 121:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** #else
 122:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 123:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 124:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 125:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 	{
 126:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 127:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 128:/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay.h **** 		while(__ticks)
 185               		.loc 3 128 0
 186 00ae 01F4      		brne .L16
 187 00b0 00C0      		rjmp .L17
 188               	.LVL9:
 189               	.L15:
 190               	.LBE28:
 191               	.LBE27:
  44:array.c       ****             PORTD = 0xFF;
 192               		.loc 1 44 0
 193 00b2 DBB8      		out 43-0x20,r13
 194               	.LVL10:
 195 00b4 80E4      		ldi r24,lo8(-25536)
 196 00b6 9CE9      		ldi r25,hi8(-25536)
 197               	.LVL11:
 198               	.L18:
 199               	.LBB31:
 200               	.LBB26:
 201               	.LBB25:
 202               	.LBB24:
 203               		.loc 2 105 0
 204 00b8 F701      		movw r30,r14
 205               	/* #APP */
 206               	 ;  105 "/usr/lib/gcc/avr/4.6.1/../../../../avr/include/util/delay_basic.h" 1
 207 00ba 3197      		1: sbiw r30,1
 208 00bc 01F4      		brne 1b
 209               	 ;  0 "" 2
 210               	.LVL12:
 211               	/* #NOAPP */
 212 00be 0197      		sbiw r24,1
 213               	.LBE24:
 214               	.LBE25:
 215               		.loc 3 128 0
 216 00c0 01F4      		brne .L18
 217               	.LVL13:
 218               	.L17:
 219 00c2 0150      		subi r16,lo8(-(-1))
 220 00c4 1040      		sbci r17,hi8(-(-1))
 221               	.LBE26:
 222               	.LBE31:
 223               	.LBE19:
  35:array.c       ****     while(count <= 4) {
 224               		.loc 1 35 0
 225 00c6 01F4      		brne .L19
  52:array.c       **** }
 226               		.loc 1 52 0
 227 00c8 80E0      		ldi r24,lo8(0)
 228 00ca 90E0      		ldi r25,hi8(0)
 229               	/* epilogue start */
 230 00cc 6496      		adiw r28,20
 231 00ce 0FB6      		in __tmp_reg__,__SREG__
 232 00d0 F894      		cli
 233 00d2 DEBF      		out __SP_H__,r29
 234 00d4 0FBE      		out __SREG__,__tmp_reg__
 235 00d6 CDBF      		out __SP_L__,r28
 236 00d8 DF91      		pop r29
 237 00da CF91      		pop r28
 238 00dc 1F91      		pop r17
 239 00de 0F91      		pop r16
 240 00e0 FF90      		pop r15
 241 00e2 EF90      		pop r14
 242 00e4 DF90      		pop r13
 243 00e6 0895      		ret
 244               	.LFE4:
 327               	.Letext0:
 328               		.file 4 "/usr/lib/gcc/avr/4.6.1/../../../../avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 array.c
     /tmp/cc9ncfLE.s:2      *ABS*:000000000000003f __SREG__
     /tmp/cc9ncfLE.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/cc9ncfLE.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/cc9ncfLE.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc9ncfLE.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc9ncfLE.s:13     .text:0000000000000000 decode
     /tmp/cc9ncfLE.s:36     .text.startup:0000000000000000 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
